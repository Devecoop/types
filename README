= devices.riflect.me

The Device Service defines a set of API to create, vision and control any device you want.


= Installation

For the Type Service to work you need to have

* {Ruby 1.9.2}[www.ruby-lang.org/en/] (use rvm[http://screencasts.org/episodes/how-to-use-rvm?utm_source=rubyweekly&utm_medium=email] to manage versions).
* {MongoDB}[http://www.mongodb.org/].

To install the project run the following commands (remember to run <tt>$ mongod</tt> before)

  $ git clone git@github.com:Lelylan/types.git
  $ cd types
  $ bundle install
  $ rake spec
  $ rails s


= API Documentation

All API supposes you have created a user with following credentials

* <b>email</b>: alice@example.com
* <b>password</b>: example

The requests accept only the JSON format, which can be set in two ways

* <b>header</b>: adding the <tt>"Accept: application/json</tt> header
* <b>suffix</b>: adding <tt>.json</tt> at the end of the URI


== Devices

A device is everything you interact with everyday of your life. In the simplest form every device belongs to a 
house and is characterized by a type (e.g dimmer, light, gate) through which the device inherit its properties 
(e.g status and intensity for a dimmer) and functions (e.g. turn on, turn off and set intensity for a dimmer).

=== Get all devices

  curl -u alice@example.com:example -i -L \
       -H "Accept: application/json" \
       http://localhost:3000/devices

=== Get a device

  curl -u alice@example.com:example -i -L \
       -H "Accept: application/json" \
       http://localhost:3000/device/{device-id}

=== Create a property

  curl -u alice@example.com:example -i \
       -H "Accept: application/json" \
       -X POST -d '{"name":"Intensity", "default": "0.0", "values":["0.0", "2.0", "4.0", "6.0", "8.0", "10.0"]}' \
       http://localhost:3000/properties

The accepted params are:

* <b>name</b>: describe the property
* <b>default</b>: default value that is inherited from the device property when created
* <b>values</b>: accepted values from the property. This is not mandatory, and if the user send a value different from the list, the service will not raise any error. Anyway it is suggested to avoid unexpected behaviours and to give a list of accepted values to UIs.

=== Update a property

  curl -u alice@example.com:example -i \
       -H "Accept: application/json" \
       -X PUT -d '{"name":"Updated Intensity", "default": "10.0"}' \
       http://localhost:3000/properties/{property-id}

=== Destroy a property

  curl -u alice@example.com:example -i -L \
       -H "Accept: application/json" -X DELETE \
       http://localhost:3000/properties/{property-id}


== Functions

Functions change the status of a device, through the change of its properties. Think at the functions as your daily interactions 
with all devices you have in your house, where you turn on a lights, close doors and raise temperature in your bedroom. Functions 
make easy to interact with your devices, as you do everyday of your life.

=== Get all functions

  curl -u alice@example.com:example -i -L \
       -H "Accept: application/json" \
       http://localhost:3000/functions

=== Get a function

  curl -u alice@example.com:example -i -L \
       -H "Accept: application/json" \
       http://localhost:3000/functions/{function-id}

=== Create a function

  curl -u alice@example.com:example -i \
       -H "Accept: application/json" \
       -X POST -d '{"name":"Set intensity"}' \
       http://localhost:3000/functions

The accepted params are:

* <b>name</b>: describe the function

=== Update a property

  curl -u alice@example.com:example -i \
       -H "Accept: application/json" \
       -X PUT -d '{"name":"Update set intensity name"}' \
       http://localhost:3000/functions/{function-id}

=== Destroy a property

  curl -u alice@example.com:example -i -L \
       -H "Accept: application/json" -X DELETE \
       http://localhost:3000/functions/{function-id}


=== Property connection

When a function is applied, is important to "explain" how the function changes the device's properties. For this reason every 
function needs the property connection which explains how the property change.


==== Get a connected property

  curl -u alice@example.com:example -i -L \
       -H "Accept: application/json" \
       http://localhost:3000/functions/{function-id}/properties?uri=http://localhost:3000/properties/{property-id}

==== Connect a property

  curl -u alice@example.com:example -i -L \
       -H "Accept: application/json" \
       -X POST -d '{"uri":"http://localhost:3000/properties/{property-id}", "secret":"true", "before":"false"}' \
       http://localhost:3000/functions/{function-id}/properties

* <b>uri</b>: property uri to connect
* <b>secret</b>: used to remember that any third party application can not store a function value (for example in a scenario), but need to always ask it to the final user. Lets think to an alarm system for example. If a service offers a "scenario" to open the house and to deactivate the alarm system, the secret code (labeled as secret) will need to be asked to the user.
* <b>before</b>: user to tell to the unite node that this property needs to be examined before applying any change. For example if we want to deactivate the alarm we send the property code labeled as "before", and the unite node will understand that this property will not be changed, but will be used as precondition to allow the device changes, that in this case is to deactivate the alarm.
* <b>values</b>: identify the value that the property have to set when the function is called. If empty, the user will send the value (see function call on device services). If set to a string value, it will be used as default value, also if it can still can be override.

==== Update a connected property

  curl -u alice@example.com:example -i -L \
       -H "Accept: application/json" \
       -X PUT -d '{"secret":"false", "before":"true"}' \
       http://localhost:3000/functions/{function-id}/properties?uri=http://localhost:3000/properties/{property-id}

==== Disconnect a property

  curl -u alice@example.com:example -i -L \
       -H "Accept: application/json" -X DELETE \
       http://localhost:3000/functions/{function-id}/properties?uri=http://localhost:3000/properties/{property-id}


== Statuses

Properties are not enough to describe the status of a device. Think at a roller shutter for example. It has the property 
“status” that can be open or close, but also opening or closing when it is "in action". To have complete and meaningful 
messages describing the status of a device in a specific moment of its life, Lelylan defines the status resource which give 
a definition of the device status through the combination of all properties values in a specific moment, through the combination
of its properties and their <b>pending status</b>.

Once you have the status of the device, you also have a message associated to it which can be used to give advanced info 
to the final user and improve the representations of your device. Even more, using statuses you can easily define “png” 
(associate an icon to every device status) or “mp3” representations of your devices which makes this resource pretty useful.


=== Get all statuses

  curl -u alice@example.com:example -i -L \
       -H "Accept: application/json" \
       http://localhost:3000/statuses

=== Get a status

  curl -u alice@example.com:example -i -L \
       -H "Accept: application/json" \
       http://localhost:3000/statuses/{status-id}

=== Create a status

  curl -u alice@example.com:example -i \
       -H "Accept: application/json" \
       -X POST -d '{"name":"Setting intensity", "template": "The <device:name/> is setting the intensity to <device:uri/>/properties?uri=devices.dev/devices/{device-id}/properties/value?uri=types.dev/properties/{property-id}} "}' \
       http://localhost:3000/statuses

TODO: Think if template could be much more clear as template_message.
TODO: Rethink at the template system, if it can be simplified, because like this seems pretty complex
TODO: Check if the authomatically generated message can always be used or if there is really the need of a template system. If yes
find a way to simplify it.
TODO: redefine a working order system.

The accepted params are:

* <b>name</b>: describe the status
* <b>template</b>: by default the type system auto generate a message status where it list the property and its value. In the case you think this is not enough, and you want to have a much more personalized message, you can do it through the definition of a template, where you can access the device name <device:name> and properties value (as you can see in the sample).

=== Update a status

  curl -u alice@example.com:example -i \
       -H "Accept: application/json" \
       -X PUT -d '{"name":"Setting intensity value"}' \
       http://localhost:3000/statuses/{status-id}


=== Destroy a status

  curl -u alice@example.com:example -i \
       -H "Accept: application/json" \
       -X DELETE -d '{"name":"Setting intensity value"}' \
       http://localhost:3000/statuses/{status-id}


=== Get a device status

  curl -u alice@example.com:example -i \
       -H "Accept: application/json" \
       -X POST -d '{"device": "DEVICE_REPRESENTATION"}' \
       http://localhost:3000/statuses/device

TODO: Rethink this service and think if there is the possibility to get the message with one request and not with a 
double (first find the status and then find the message)

=== Get message status

  curl -u alice@example.com:example -i \
       -H "Accept: application/json" \
       -X POST -d '{"device": "DEVICE_REPRESENTATION"}' \
       http://localhost:3000/statuses/{status-id}/message


=== Status icon (visual representation)

==== Get a status icon

  curl -u alice@example.com:example -i -L \
       -H "Accept: application/json" \
       http://localhost:3000/statuses/{status-id}/icon

==== Create the status icon

  curl -u alice@example.com:example \
       -s -F icon=@spec/fixtures/media/square.png \
       -X PUT http://localhost:3000/statuses/{status-id}/icon


=== Property connection

Define which properties define the status of a device in a certain moment of its life.

==== Get a connected property

  curl -u alice@example.com:example -i -L \
       -H "Accept: application/json" \
       http://localhost:3000/statuses/{status-id}/properties?uri=http://localhost:3000/properties/{property-id}

==== Connect a property

  curl -u alice@example.com:example -i -L \
       -H "Accept: application/json" \
       -X POST -d '{"uri":"http://localhost:3000/properties/{property-id}", "pending":"true"}' \
       http://localhost:3000/statuses/{status-id}/properties

* <b>uri</b>: property uri to connect
* <b>pending</b>: used to know if the property is changed on the device or not. 
* <b>values</b>: identify the value that the property must have to match the status. There must be more statuses that can match a 
specific device representation. In this cases an order must be defined and the first matching will be chosen.

==== Update a connected property

  curl -u alice@example.com:example -i -L \
       -H "Accept: application/json" \
       -X PUT -d '{"pending": "true"}' \
       http://localhost:3000/statuses/{status-id}/properties?uri=http://localhost:3000/properties/{property-id}

==== Disconnect a property

  curl -u alice@example.com:example -i -L \
       -H "Accept: application/json" -X DELETE \
       http://localhost:3000/statuses/{statuses-id}/properties?uri=http://localhost:3000/properties/{property-id}


== Author

== Changelog

== License

